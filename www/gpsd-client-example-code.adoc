= gpsd Client Example Code
Gary E. Miller <gem@rellim.com>
15 July 2021
:author: Gary E. Miller
:description: A line by line code walk-through of a simple gpsd C client.
:email: <gem@rellim.com>
:keywords: gpsd, example
:robots: index,follow
:sectlinks:
:source-highlighter: rouge
:toc: macro

include::inc-menu.adoc[]

== ABSTRACT

This document supplies some code examples that show how to write
good *gpsd* clients.  It is an attempt to supplant the myriad bad
Stack Overflow examples of *gpsd* clients.

== EXAMPLE 1

A simple *gpsd* client that connects to the already running *gpsd* on
the _localhost_ running on the default port _2947_, using TCP.  You need
to already have *gpsd* installed, with its libraries, and running, on your
host for this example to run.

Grab a copy of https://gpsd.io/example1.c.txt[example1.c], rename it
to not have the .txt extension (an scons bug workaround), compile it,
and run it. i The example builds and runs fine as a normal user as it
does not require any special permissions. Use "^C" to exit.  Like
this:

[source%nowrap,terminal]
----
$ wget -o example1.c https://gpsd.io/example1.c.txt
$ gcc example1.c -o example1 -lgps -lm
$ ./example1
pECEF  -1999227.86 m: X:  -3929865.50 m: Y:  4593852.52 m: Z        5.50m: pAcc

vECEF     +0.01 m/s: vX:      +0.00 m/s: vY:      +0.01 m/s: vZ      +0.27 m/s :vAcc

DOP [h]: +0.9 [v]: +1.5 [p]: +1.8 [t]: +0.9 [g]: +2.0

Fix mode: 3D (3) Time: 1656776419.000000000 Lat 46.367406 Lon -116.963660

skyview: using 11 of 19 satellites for /dev/ttyUSB0

        Sig Frq Hlt Qlt U con sat   s/n    el     az prRes
        === === === === = === === ===== ===== ====== ===== 
          0  -1   1   0 Y   0   2  22.0  48.0  190.0   0.0
          0  -1   1   0 Y   0   3  26.0   9.0   32.0   0.0
          0  -1   1   0 Y   0   6  34.0  67.0  102.0   0.0
          0  -1   1   0 Y   0  11  32.0  47.0  179.0   0.0
          0  -1   1   0 Y   0  12  34.0  55.0  305.0   0.0
          0  -1   1   0 -   0  14   0.0   1.0  121.0   0.0
          0  -1   1   0 Y   0  17  32.0  25.0   66.0   0.0
          0  -1   1   0 Y   0  19  40.0  48.0   59.0   0.0
          0  -1   1   0 -   0  20   0.0   4.0  160.0   0.0
          0  -1   1   0 -   0  22   0.0   2.0  338.0   0.0
          0  -1   1   0 Y   0  24  35.0  43.0  238.0   0.0
          0  -1   1   0 Y   0  25  30.0  14.0  303.0   0.0
          0  -1   1   0 -   0  28  34.0  26.0  117.0   0.0
          0  -1   1   0 -   0  32  30.0   3.0  317.0   0.0
          0  -1   1   0 Y   1 133  35.0  35.0  197.0   0.0
          0  -1   1   0 Y   1 135  30.0  36.0  191.0   0.0
          0  -1   1   0 -   1 138   0.0  35.0  167.0   0.0
          0  -1   1   0 -   5   1   0.0   n/a    0.0   0.0
          0  -1   1   0 -   5   2   0.0   1.0  297.0   0.0

pECEF  -1999227.86 m: X:  -3929865.50 m: Y:  4593852.52 m: Z        5.50m: pAcc
^C
----
 
The paranoid reader will have read https://gpsd.io/example1.c[example1.c]
before running it so as not to lose all their Bitcoin.

As you can see above, this client prints the "Fix Mode" ("mode"), Time
("time"), "latitude" and "longitude" if available.  These are the Time and
Position parts of the acronym _TPV_.  Otherwise it prints nothing.

Adding Velocity output is left as an exercise to the reader.

Note: The "Time" is the time of the fix, not the current time.

// The source highlighter and line numbers requires rouge to be installed
// Keep the line numbers in sync with the text.

The complete example1.c:

[source%nowrap,c,numbered]
----
include::example1.c.txt[]
----

=== COMMENTARY

Line by line commentary:

Lines 1 to 4::
[source%nowrap,c,numbered]
----
// example  gpsd client
// compile this way:
//    gcc example1.c -o example1 -lgps -lm
#include <gps.h>
----

All you need to compile this example is *libgps*, and *gps.h*, installed
on your host.  Those two files should have been installed when you
installed *gpsd* on your system.  The gcc option *-lgps* links in
*libgps* and *-lm* links in libm.  Some systems will automatically link
in *libm*.

Line 5 to 9::
[source%nowrap,c,numbered,start=5]
----
#include <errno.h>      // for errno
#include <math.h>       // for infinite()
#include <stdio.h>      // for puts(), printf(), perror()
#include <stdlib.h>     // for exit()
#include <string.h>     // for strnlen()
----

The system includes are to get prototypes for the listed functions.

Lines 11 to 21::
[source%nowrap,c,numbered,start=11]
----
#define GPS_HAS_BIT_SET(x) (x == (x & gps_data.set))
#define MS_IN_US (1000)
#define NS_IN_SEC (1000 * 1000 * 1000)
----
Several definitions that will be useful later. GPS_HAS_BIT_SET is useful for
testing if data is valid, MS_IN_US is useful for gps_waiting, and NS_IN_SEC
is useful for splitting timestamps.

Lines 11 to 21::
[source%nowrap,c,numbered,start=21]
----
#define MODE_STR_NUM 4
static char *mode_str[MODE_STR_NUM] = {
    "n/a",
    "None",
    "2D",
    "3D"
};
----
An array of strings used to convert _gps_data.fix.mode_ integer to a
nice Fix Type string.

Lines 23 to 34::
[source%nowrap,c,numbered,start=23]
----
void printfloat(char *prep, int flen, char *fmt, double f) {
    if (flen < 3) {
        
        exit(1);
    }
    if (0 != isfinite(f)) {
        (void)printf("%s", prep);
        (void)printf(fmt, f);
    } else {
        (void)printf("%s%*s", prep, flen, "n/a");
    }
}
----
A useful little function if flen is less than 3 (the width of n/a) the
program exits with an error. In the typical case though, it prints prep,
and then f in a fmt formatted field when f is finite and 'n/a' (sans
quotes if f is not finite.

Lines 36 to 42::
[source%nowrap,c,numbered,start=36]
----
void toff_dump(struct timedelta_t *pps) {
    printf("\nReal  Time: %10ld.%09ld\n",
        pps->real.tv_sec, pps->real.tv_nsec);
    printf("Clock Time: %10ld.%09ld\n",
        pps->clock.tv_sec, pps->clock.tv_nsec);
}
----
A less used function which prints out two numeric timestamps for GPS and
host system time.

Lines 43 to 44::
[source%nowrap,c,numbered,start=43]
----
int main(int argc, char *argv[])
{
----

All we need is a simple main().  For clarity no options handling is done
in this example.  Real programs will implement options and arguments:
*-h*; *-V*; *[server[;port[;device]]*; etc.

Line 45 to 47::
[source%nowrap,c,numbered,start=45]
----
    struct gps_data_t gps_data;
    struct timedelta_t *pps;
    int live = 1;
----

Every variable we care about, all variables, are contained in
*struct gps_data_t gps_data* which is defined, and documented, in
*gps.h*. *gps_data* contains a *struct gps_fix_t fix* which is also
defined in *gps.h*.  The _TPV_ data we will use is in _gps_data.fix_.
pps is a variable to save us from having two duplicate code blocks which
print out struct timedelta_t from PPS and TOFF sentences respectively.
live is a loop continuation variable when 0 the loop breaks.

Line 48 to 51::
[source%nowrap,c,numbered,start=48]
----
    if (0 != gps_open("::1", "2947", &gps_data)) {
        printf("Open error.  Bye, bye\n");
        return 1;
    }
----

Connect to the already running *gpsd* on the _localhost_ running on the
default port _2947_.  Or exit loudly.  See the *gpsd(3)* man page for
details on starting *gpsd*. There may be significant delays opening
the connection if *gpsd* is not running with the "-n" option. See the
*libgps* man page for details on *gps_open()* and the other *gps_XXX()*
function calls.

Note the use of <<Yoda>> conditions.  These prevent many hard to spot
code errors.

Line 54::
[source%nowrap,c,numbered,start=54]
----
    (void)gps_stream(&gps_data, WATCH_ENABLE | WATCH_JSON, NULL);
----

Tell *gpsd* to send us reports using JSON. Later on *gpsd_read()* will
decode those JSON messsages for us.  See the <<gpsd_json>> man page for
details on the JSON messages.

Line 56 to 63::
[source%nowrap,c,numbered,start=56]
----
    while ((0 == errno)&&(0 < live)) {
        if (0 == gps_waiting(&gps_data, MS_IN_US * 5)) {
            if (0 != errno) {
                perror("gps_waiting()");
                break;
            }
            continue;
        }
----

The main loop. Wait, using *gps_waiting()* until data from the *gpsd*
connection is available, then run the body of the loop. Stop if there
is an error or we no longer wish to proceed. Wait a maximum of five
milliseconds between loops.

Lines 64 to 67::
[source%nowrap,c,numbered,start=64]
----
        if (-1 == gps_read(&gps_data, NULL, 0)) {
            printf("Read error.  Bye, bye\n");
            break;
        }
----

Read the waiting data using *gpsd_read()* and parse it into *gps_data*.
Exit loudly on errors. No telling, yet, what the data is.  It could be
from *TPV*, *SKY*, *AIS*, or other message classes.

Lines 68 to 71::
[source%nowrap,c,numbered,start=68]
----
        if (!GPS_HAS_BIT_SET(MODE_SET)) {
            // did not even get mode, nothing to see here
            continue;
        }
----

Here is a part that most programmers miss.  Check that *TPV* data was
received, not some other data, like *SKY*.  The flag *MODE_SET* is set
IF a *TPV* JSON sentence was received.  If no *MODE_SET* then do not
bother to look at the rest of the data in _gpsdata.fix_.

Lines 72 to 75::
[source%nowrap,c,numbered,start=72]
----
        if (0 > gps_data.fix.mode ||
            MODE_STR_NUM <= gps_data.fix.mode) {
            gps_data.fix.mode = 0;
        }
----

Range check _gpsdata.fix.mode_ so we can use it as an index into
_mode_str_.  New versions of *gpsd* often extend the range of
unenumerated types, so protect yourself from an array overrun.  Array
overruns are bad.

Lines 76 to 78::
[source%nowrap,c,numbered,start=76]
----
        printf("Fix mode: %s (%d) Time: ",
               mode_str[gps_data.fix.mode],
               gps_data.fix.mode);
----

Print the Fix mode as an integer, and a string.

Lines 79 to 85::
[source%nowrap,c,numbered,start=79]
----
        if (GPS_HAS_BIT_SET(TIME_SET)) {
            // not 32 bit safe
            printf("%ld.%09ld ", gps_data.fix.time.tv_sec,
                   gps_data.fix.time.tv_nsec);
        } else {
            puts("n/a ");
        }
----

Print the _gps_data.fix.time_ as seconds and nano seconds into the UNIX
epoch, if we have it, else "n/a". _fix.time_ is a *struct timespec*.  An
explanation of *struct timespec* can be found on the *clock_gettime()*
man page.

Just because we have a "valid" time does not mean it bears any relation
to UTC.  Many GPS/GNSS receivers output random time when they do not
have a fix.  Worse, some continue to do so for minutes after reporting
that they have a valid fix.

Lines 86 to 91::
[source%nowrap,c,numbered,start=86]
----
        if (GPS_HAS_BIT_SET(LATLON_SET)) {
            // Display data from the GPS receiver if valid.
            printfloat("Lat ", 3, " %.6f", gps_data.fix.latitude);
            printfloat("Lon ", 3, " %.6f", gps_data.fix.longitude);
        }
        puts("");
----

Just because we have a "3D" fix does not mean we have _latitude_ and
_longitude_.  The receiver may not have sent that data yet.  Conversely,
some receivers will send them, without a fix, based on some best guess.
This example prints them if we get them regardless of fix "mode" or
"status".

When *gpsd* does not know the value of a floating point variable, it
sets that variable to a *NaN* (Not a Number).  So the example checks if
_latitude_ and _longitude_ are set by seeing if they are finite numbers by
using *isfinite()* from *libm*.  Do not use *isnan()*!  See <<NUMBERS>>
for a more detailed explanation about this issue.

Lines 94 to 119::
[source%nowrap,c,numbered,start=94]
----
        if (GPS_HAS_BIT_SET(SATELLITE_SET)) {
            struct satellite_t sat;
            printf("\nskyview: using %d of %d satellites for %s\n\n",
                gps_data.satellites_used,
                gps_data.satellites_visible,
                ((GPS_PATH_MAX > strnlen(gps_data.dev.path, GPS_PATH_MAX))
                 &&(gps_data.dev.path[0] != 0)) ? gps_data.dev.path : "???");
            printf("\t%s\n",
                   "Sig Frq Hlt Qlt U PRN con sat   s/n    el     az prRes");
            printf("\t%s",
                   "=== === === === = === === === ===== ===== ====== ===== ");
            for (int i=0; i < gps_data.satellites_visible; i++) {
                sat = gps_data.skyview[i];
                printf("\n\t%3d %3d %3d %3d %1s %3d %3d %3d",
                    sat.sigid, sat.freqid,
                    sat.health, sat.qualityInd,
                    sat.used ? "Y" : "-",
                    sat.PRN, sat.gnssid, sat.svid);
                printfloat("", 6, " %5.1f", sat.ss);
                printfloat("", 6, " %5.1f", sat.elevation);
                printfloat("", 7, " %6.1f", sat.azimuth);
                printfloat("", 6, " %5.1f", sat.prRes);
            }
            puts("\n");
        }
----
print out sky view data if available.


Lines 121 to 128::
[source%nowrap,c,numbered,start=121]
----
//        if (GPS_HAS_BIT_SET(ECEF_SET)) { // libgps set ECEF_SET broken?
        if (isfinite(gps_data.fix.ecef.x)) {
            printfloat("pECEF ",  11, " %10.2f", gps_data.fix.ecef.x);
            printfloat(" m: X: ",    11, " %10.2f", gps_data.fix.ecef.y);
            printfloat(" m: Y: ",    11, " %10.2f", gps_data.fix.ecef.z);
            printfloat(" m: Z ", 11, " %10.2f", gps_data.fix.ecef.pAcc);
            puts("m: pAcc\n");
        }
----
Output Earth Centered Earth Fixed positioning data if available.

Lines 130 to 137::
[source%nowrap,c,numbered,start=130]
----
//        if (GPS_HAS_BIT_SET(VECEF_SET)) { // libgps set VECEF_SET broken?
        if (isfinite(gps_data.fix.ecef.vx)) {
            printfloat("vECEF",       8, " %+9.2f", gps_data.fix.ecef.vx);
            printfloat(" m/s: vX: ",  8, " %+9.2f", gps_data.fix.ecef.vy);
            printfloat(" m/s: vY: ",  8, " %+9.2f", gps_data.fix.ecef.vz);
            printfloat(" m/s: vZ ",   8, " %+9.2f", gps_data.fix.ecef.vAcc);
            puts(" m/s :vAcc\n");
        }
----
Output ECEF Velocity information if available.

Lines 139 to 146::
[source%nowrap,c,numbered,start=139]
----
        if (GPS_HAS_BIT_SET(DOP_SET)) {
            printfloat("DOP [h]: ", 3, "%+4.1f", gps_data.dop.hdop);
            printfloat(" [v]: ",    3, "%+4.1f", gps_data.dop.vdop);
            printfloat(" [p]: ",    3, "%+4.1f", gps_data.dop.pdop);
            printfloat(" [t]: ",    3, "%+4.1f", gps_data.dop.tdop);
            printfloat(" [g]: ",    3, "%+4.1f", gps_data.dop.gdop);
            puts("\n");
        }
----
Checks if Dilution Of Precision data is available and dump it.

Lines 148 to 159::
[source%nowrap,c,numbered,start=148]
----
        if (GPS_HAS_BIT_SET(PPS_SET)) {
            pps = &gps_data.pps;
            printf("PPS Quantization error adjustment: %6ld.%09ldns\n",
                   gps_data.qErr/NS_IN_SEC, gps_data.qErr%NS_IN_SEC);
            toff_dump(pps);
        }

        if (GPS_HAS_BIT_SET(TOFF_SET)) {
            puts("Time Offest");
            pps = &gps_data.toff;
            toff_dump(pps);
        }
----
If your gpsd instance gets enough information to produce PPS or TOFF data
this is the code that will print out that data.

Lines 163 to 167::
[source%nowrap,c,numbered,start=163]
----
    // When you are done...
    (void)gps_stream(&gps_data, WATCH_DISABLE, NULL);
    (void)gps_close(&gps_data);
    return 0;
}
----

When falling out of the loop, close the TCP connection nicely
and return success.  Mother always said to clean up after myself.

== REFERENCES

[bibliography]
* [[[IEEE754]]] https://standards.ieee.org/standard/754-2019.html[IEEE Standard
for Floating-Point Arithmetic]

* [[[Yoda]]] https://en.wikipedia.org/wiki/Yoda_conditions[Yoda Conditions]

* [[[libgps]]] {gpsdweb}libgps.html[libgps(3)]

* [[[gpsd_json]]] {gpsdweb}gpsd_json.html[gpsd_json(5)]

* [[[gpsd]]] {gpsdweb}gpsd.html[gpsd(8)]

* {gpsdweb}client-howto.html[GPSD Client HOWTO] is a different look at
*gpsd* clients.

* [[[NUMBERS]]] {gpsdweb}gpsd-numbers-matter.html[GPSD Numbers Matter]

* *isfinite(3)*

* *GPSD Project web site:* {gpsdweb}

== COPYING

This file is Copyright 2021 by the GPSD project +
SPDX-License-Identifier: BSD-2-clause
