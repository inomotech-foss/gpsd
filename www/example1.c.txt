// example  gpsd client
// compile this way:
//    gcc example1.c -o example1 -lgps -lm
#include <gps.h>
#include <errno.h>      // for errno
#include <math.h>       // for infinite()
#include <stdio.h>      // for puts(), printf(), perror()
#include <stdlib.h>     // for exit()
#include <string.h>     // for strnlen()

#define GPS_HAS_BIT_SET(x) (x == (x & gps_data.set))
#define MS_IN_US (1000)
#define NS_IN_SEC (1000 * 1000 * 1000)

#define MODE_STR_NUM 4
static char *mode_str[MODE_STR_NUM] = {
    "n/a",
    "None",
    "2D",
    "3D"
};

void printfloat(char *prep, int flen, char *fmt, double f) {
    if (3 < flen) {
        
        exit(1);
    }
    if (0 != isfinite(f)) {
        (void)printf("%s", prep);
        (void)printf(fmt, f);
    } else {
        (void)printf("%s%*s", prep, flen, "n/a");
    }
}

void toff_dump(struct timedelta_t *pps) {
    printf("\nReal  Time: %10ld.%09ld\n",
        pps->real.tv_sec, pps->real.tv_nsec);
    printf("Clock Time: %10ld.%09ld\n",
        pps->clock.tv_sec, pps->clock.tv_nsec);
}

int main(int argc, char *argv[])
{
    struct gps_data_t gps_data;
    struct timedelta_t *pps;
    int live = 1;

    if (0 != gps_open("::1", "2947", &gps_data)) {
        printf("Open error.  Bye, bye\n");
        return 1;
    }

    (void)gps_stream(&gps_data, WATCH_ENABLE | WATCH_JSON, NULL);

    while ((0 == errno)&&(0 < live)) {
        if (0 == gps_waiting(&gps_data, MS_IN_US * 5)) {
            if (0 != errno) {
                perror("gps_waiting()");
                break;
            }
            continue;
        }
        if (-1 == gps_read(&gps_data, NULL, 0)) {
            printf("Read error.  Bye, bye\n");
            break;
        }
        if (!GPS_HAS_BIT_SET(MODE_SET)) {
            // did not even get mode, nothing to see here
            continue;
        }
        if (0 > gps_data.fix.mode ||
            MODE_STR_NUM <= gps_data.fix.mode) {
            gps_data.fix.mode = 0;
        }
        printf("Fix mode: %s (%d) Time: ",
               mode_str[gps_data.fix.mode],
               gps_data.fix.mode);
        if (GPS_HAS_BIT_SET(TIME_SET)) {
            // not 32 bit safe
            printf("%ld.%09ld ", gps_data.fix.time.tv_sec,
                   gps_data.fix.time.tv_nsec);
        } else {
            puts("n/a ");
        }
        if (GPS_HAS_BIT_SET(LATLON_SET)) {
            // Display data from the GPS receiver if valid.
            printfloat("Lat ", 3, " %.6f", gps_data.fix.latitude);
            printfloat("Lon ", 3, " %.6f", gps_data.fix.longitude);
        }
        puts("");


        if (GPS_HAS_BIT_SET(SATELLITE_SET)) {
            struct satellite_t sat;
            printf("\nskyview: using %d of %d satellites for %s\n\n",
                gps_data.satellites_used,
                gps_data.satellites_visible,
                ((GPS_PATH_MAX > strnlen(gps_data.dev.path, GPS_PATH_MAX))
                 &&(gps_data.dev.path[0] != 0)) ? gps_data.dev.path : "???");
            printf("\t%s\n",
                   "Sig Frq Hlt Qlt U PRN con sat   s/n    el     az prRes");
            printf("\t%s",
                   "=== === === === = === === === ===== ===== ====== ===== ");
            for (int i=0; i < gps_data.satellites_visible; i++) {
                sat = gps_data.skyview[i];
                printf("\n\t%3d %3d %3d %3d %1s %3d %3d %3d",
                    sat.sigid, sat.freqid,
                    sat.health, sat.qualityInd,
                    sat.used ? "Y" : "-",
                    sat.PRN, sat.gnssid, sat.svid);
                printfloat("", 6, " %5.1f", sat.ss);
                printfloat("", 6, " %5.1f", sat.elevation);
                printfloat("", 7, " %6.1f", sat.azimuth);
                printfloat("", 6, " %5.1f", sat.prRes);
            }
            puts("\n");
        }

//        if (GPS_HAS_BIT_SET(ECEF_SET)) { // libgps set ECEF_SET broken?
        if (isfinite(gps_data.fix.ecef.x)) {
            printfloat("pECEF ",  11, " %10.2f", gps_data.fix.ecef.x);
            printfloat(" m: X: ",    11, " %10.2f", gps_data.fix.ecef.y);
            printfloat(" m: Y: ",    11, " %10.2f", gps_data.fix.ecef.z);
            printfloat(" m: Z ", 11, " %10.2f", gps_data.fix.ecef.pAcc);
            puts("m: pAcc\n");
        }

//        if (GPS_HAS_BIT_SET(VECEF_SET)) { // libgps set VECEF_SET broken?
        if (isfinite(gps_data.fix.ecef.vx)) {
            printfloat("vECEF",       8, " %+9.2f", gps_data.fix.ecef.vx);
            printfloat(" m/s: vX: ",  8, " %+9.2f", gps_data.fix.ecef.vy);
            printfloat(" m/s: vY: ",  8, " %+9.2f", gps_data.fix.ecef.vz);
            printfloat(" m/s: vZ ",   8, " %+9.2f", gps_data.fix.ecef.vAcc);
            puts(" m/s :vAcc\n");
        }

        if (GPS_HAS_BIT_SET(DOP_SET)) {
            printfloat("DOP [h]: ", 3, "%+4.1f", gps_data.dop.hdop);
            printfloat(" [v]: ",    3, "%+4.1f", gps_data.dop.vdop);
            printfloat(" [p]: ",    3, "%+4.1f", gps_data.dop.pdop);
            printfloat(" [t]: ",    3, "%+4.1f", gps_data.dop.tdop);
            printfloat(" [g]: ",    3, "%+4.1f", gps_data.dop.gdop);
            puts("\n");
        }

        if (GPS_HAS_BIT_SET(PPS_SET)) {
            pps = &gps_data.pps;
            printf("PPS Quantization error adjustment: %6ld.%09ldns\n",
                   gps_data.qErr/NS_IN_SEC, gps_data.qErr%NS_IN_SEC);
            toff_dump(pps);
        }

        if (GPS_HAS_BIT_SET(TOFF_SET)) {
            puts("Time Offest");
            pps = &gps_data.toff;
            toff_dump(pps);
        }

        //gps_data.set = 0;
    }
    
    // When you are done...
    (void)gps_stream(&gps_data, WATCH_DISABLE, NULL);
    (void)gps_close(&gps_data);
    return 0;
}
