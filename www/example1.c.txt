// tag::Head[]
// example  gpsd client
// compile this way:
//    gcc example1.c -o example1 -lgps -lm
#include <gps.h>
// end::Head[]
// tag::Include[]
#include <errno.h>  // for errno
#include <math.h>   // for infinite()
#include <stdio.h>  // for puts(), printf(), perror()
#include <stdlib.h> // for exit()
#include <string.h> // for strnlen()
// end::Include[]

// tag::Macros[]
#define IS_GPS(x) (x == (x & gps_data.set))
#define MS_IN_US (1000)
#define NS_IN_SEC (1000 * 1000 * 1000)
// end::Macros[]

// tag::Mode[]
#define MODE_STR_NUM 4
static char *mode_str[MODE_STR_NUM] = {
    "n/a",
    "None",
    "2D",
    "3D"
};
// end::Mode[]

// tag::Float[]
// void printfloat: print text label, then either a finite double or n/a
//
// char * prep: text lablel to prepend
// int flen:    width of n/a if not finite (minimum 3)
// char * fmt:  printf format string for f if finite
// double f:    double floating point number to print if finite
void printfloat(char *prep, int flen, char *fmt, double f) {
    if (3 < flen) {
        
        exit(1);
    }
    if (0 != isfinite(f)) {
        (void)printf("%s", prep);
        (void)printf(fmt, f);
    } else {
        (void)printf("%s%*s", prep, flen, "n/a");
    }
}
// end::Float[]

// tag::Toff[]
// void toff_dump:  print the GPS and host time stored in pps
//
// struct timedelta_t * pps:    GPS and system times in time_val
void toff_dump(struct timedelta_t *pps) {
    printf("\nReal  Time: %10ld.%09ld\n",
        pps->real.tv_sec, pps->real.tv_nsec);
    printf("Clock Time: %10ld.%09ld\n",
        pps->clock.tv_sec, pps->clock.tv_nsec);
}
// end::Toff[]

// tag::main[]
int main(int argc, char *argv[])
{
// end::main[]
// tag::vars[]
    struct gps_data_t gps_data;
    struct timedelta_t *pps;
    int live = 1;
    errno = 0;
// end::vars[]

// tag::open[]
    if (0 != gps_open("localhost", "2947", &gps_data)) {
        printf("Open error.  Bye, bye\n");
        return 1;
    }
// end::open[]

// tag::stream[]
    (void)gps_stream(&gps_data, WATCH_ENABLE | WATCH_JSON, NULL);
// end::stream[]

// tag::wait[]
    while ((0 == errno)&&(0 < live)) {
        if (0 == gps_waiting(&gps_data, MS_IN_US * 5)) {
            if (0 != errno) {
                perror("gps_waiting()");
                break;
            }
            continue;
        }
// end::wait[]
// tag::read[]
        if (-1 == gps_read(&gps_data, NULL, 0)) {
            printf("Read error.  Bye, bye\n");
            break;
        }
// end::read[]
// tag::hasmode[]
        if (!IS_GPS(MODE_SET)) {
            // did not even get mode, nothing to see here
            continue;
        }
// end::hasmode[]
// tag::clipmode[]
        if (0 > gps_data.fix.mode ||
            MODE_STR_NUM <= gps_data.fix.mode) {
            gps_data.fix.mode = 0;
        }
// end::clipmode[]
// tag::printmode[]
        printf("Fix mode: %s (%d) Time: ",
               mode_str[gps_data.fix.mode],
               gps_data.fix.mode);
// end::printmode[]
// tag::time[]
        if (IS_GPS(TIME_SET)) {
            // not 32 bit safe
            printf("%ld.%09ld", gps_data.fix.time.tv_sec,
                   gps_data.fix.time.tv_nsec);
        } else {
            puts("n/a");
        }
// end::time[]
// tag::latlon[]
        if (IS_GPS(LATLON_SET)) {
            // Display data from the GPS receiver if valid.
            printfloat("\tLat ", 3, " %.6f", gps_data.fix.latitude);
            printfloat("\tLon ", 3, " %.6f", gps_data.fix.longitude);
        }
        puts("");
// end::latlon[]


        // tag::SkyView[]
        if (IS_GPS(SATELLITE_SET)) {
            struct satellite_t sat;
            printf("\nskyview: using %d of %d satellites for %s\n\n",
                gps_data.satellites_used,
                gps_data.satellites_visible,
                ((sizeof(gps_data.dev.path) > strnlen(gps_data.dev.path, (sizeof(gps_data.dev.path))))
                 &&(gps_data.dev.path[0] != 0)) ? gps_data.dev.path : "???");
            printf("\t%s\n",
                   "Sig Frq Hlt Qlt U PRN con sat   s/n    el     az prRes");
            printf("\t%s",
                   "=== === === === = === === === ===== ===== ====== ===== ");
            for (int i=0; i < gps_data.satellites_visible; i++) {
                sat = gps_data.skyview[i];
                printf("\n\t%3d %3d %3d %3d %1s %3d %3d %3d",
                    sat.sigid, sat.freqid,
                    sat.health, sat.qualityInd,
                    sat.used ? "Y" : "-",
                    sat.PRN, sat.gnssid, sat.svid);
                printfloat("", 6, " %5.1f", sat.ss);
                printfloat("", 6, " %5.1f", sat.elevation);
                printfloat("", 7, " %6.1f", sat.azimuth);
                printfloat("", 6, " %5.1f", sat.prRes);
            }
            puts("\n");
        }
        // end::SkyView[]
        

        // tag::pECEF[]
//        if (IS_GPS(ECEF_SET)) { // libgps set ECEF_SET broken?
        if (isfinite(gps_data.fix.ecef.x)) {
            printfloat("pECEF ",  11, " %10.2f", gps_data.fix.ecef.x);
            printfloat(" m: X: ",    11, " %10.2f", gps_data.fix.ecef.y);
            printfloat(" m: Y: ",    11, " %10.2f", gps_data.fix.ecef.z);
            printfloat(" m: Z ", 11, " %10.2f", gps_data.fix.ecef.pAcc);
            puts("m: pAcc\n");
        }
        // end::pECEF[]

        // tag::vECEF[]
//        if (IS_GPS(VECEF_SET)) { // libgps set VECEF_SET broken?
        if (isfinite(gps_data.fix.ecef.vx)) {
            printfloat("vECEF",       8, " %+9.2f", gps_data.fix.ecef.vx);
            printfloat(" m/s: vX: ",  8, " %+9.2f", gps_data.fix.ecef.vy);
            printfloat(" m/s: vY: ",  8, " %+9.2f", gps_data.fix.ecef.vz);
            printfloat(" m/s: vZ ",   8, " %+9.2f", gps_data.fix.ecef.vAcc);
            puts(" m/s :vAcc\n");
        }
        // end::vECEF[]

        // tag::DoP[]
        if (IS_GPS(DOP_SET)) {
            printfloat("DOP [h]: ", 3, "%+4.1f", gps_data.dop.hdop);
            printfloat(" [v]: ",    3, "%+4.1f", gps_data.dop.vdop);
            printfloat(" [p]: ",    3, "%+4.1f", gps_data.dop.pdop);
            printfloat(" [t]: ",    3, "%+4.1f", gps_data.dop.tdop);
            printfloat(" [g]: ",    3, "%+4.1f", gps_data.dop.gdop);
            puts("\n");
        }
        // end::DoP[]

        // tag::PPSTOff[]
        if (IS_GPS(PPS_SET)) {
            pps = &gps_data.pps;
            printf("PPS Quantization error adjustment: %6ld.%09ldns\n",
                   gps_data.qErr/NS_IN_SEC, gps_data.qErr%NS_IN_SEC);
            toff_dump(pps);
        }

        if (IS_GPS(TOFF_SET)) {
            puts("Time Offest");
            pps = &gps_data.toff;
            toff_dump(pps);
        }
        // end::PPSTOff[]
    }

    // tag::Done[]
    // When you are done...
    (void)gps_stream(&gps_data, WATCH_DISABLE, NULL);
    (void)gps_close(&gps_data);
    return 0;
    // end::Done[]
}
